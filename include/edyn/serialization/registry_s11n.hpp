#ifndef EDYN_SERIALIZATION_REGISTRY_S11N_HPP
#define EDYN_SERIALIZATION_REGISTRY_S11N_HPP

#include <cstdint>
#include <initializer_list>
#include <numeric>
#include <unordered_map>
#include <entt/entt.hpp>
#include "edyn/util/entity_map.hpp"
#include "edyn/util/component_identifier.hpp"

namespace edyn {

/**
 * Registry serialization data format:
 * - Number of created or updated entities followed by an array of entities.
 * - Number of created or updated components followed by an array where each
 *   element contains an entity, a component id and the component data.
 * - Number of deleted components followed by an array where each element
 *   contains an entity and a component id.
 * The first array of entities is useful especially in the 
 * `registry_snapshot_importer` because it needs to create all entities before
 * loading components that contain child entities which need to be mapped into
 * the local registry space.
 * In the `registry_snapshot_exporter` it will follow the block of data in the
 * format above with another block with the same format for entities that don't
 * yet have a mapping onto the external registry.
 */

using entity_comp_id_pair = std::pair<entt::entity, component_identifier_t>;

/**
 * @brief The `registry_snapshot_writer` stores a reference to a registry and a
 * list of entities and component types to be serialized. It must be serialized
 * with an output archive.
 * @tparam Component The list of component types that can be serialized using
 *      this writer. Readers and importers that process the data generated by
 *      this writer must use the same list of components in the same order, or
 *      else the component identifiers won't match.
 */
template<typename... Component>
class registry_snapshot_writer {

    template<typename Comp, typename Archive>
    void serialize_component(Archive &archive, entt::entity entity) {
        if constexpr(!std::is_empty_v<Comp>) {
            auto &comp = m_registry->get<Comp>(entity);
            archive(comp);
        }
    }

    template<typename Archive, component_identifier_t... Indexes>
    void serialize_component(Archive &archive, entt::entity entity, component_identifier_t comp_id, std::integer_sequence<component_identifier_t, Indexes...>) {
        ((comp_id == Indexes ? serialize_component<std::tuple_element_t<size_t{Indexes}, tuple_type>>(archive, entity) : (void)0), ...);
    }

    template<typename Archive>
    void serialize_component(Archive &archive, entt::entity entity, component_identifier_t comp_id) {
        serialize_component(archive, entity, comp_id, std::make_integer_sequence<component_identifier_t, sizeof...(Component)>{});
    }

public:
    using tuple_type = std::tuple<Component...>;

    registry_snapshot_writer(entt::registry &reg) 
        : m_registry(&reg)
    {}

    registry_snapshot_writer(entt::registry &reg, [[maybe_unused]] tuple_type) 
        : m_registry(&reg)
    {}

    template<typename... Comp>
    void updated(entt::entity entity) {
        m_updated_entities.push_back(entity);
        if constexpr(sizeof...(Comp) > 0) {
            ((m_registry->has<Comp>(entity) ? m_updated_components.push_back(entity_comp_id_pair{entity, component_identifier<Component...>::template value<Comp>}) : (void)0), ...);
        }
    }

    template<typename... Comp>
    void updated(entt::entity entity, [[maybe_unused]] std::tuple<Comp...>) {
        updated<Comp...>(entity);
    }

    template<typename It>
    void updated(It first, It last) {
        for (auto it = first; it != last; ++it) {
            auto entity = it->first;
            m_updated_entities.push_back(entity);
        }
        std::copy(first, last, std::back_inserter(m_updated_components));
    }

    template<typename... Comp>
    void destroyed(entt::entity entity) {
        (m_destroyed_components.push_back(entity_comp_id_pair{entity, component_identifier<Component...>::template value<Comp>}), ...);
    }

    template<typename It>
    void destroyed(It first, It last) {
        std::copy(first, last, std::back_inserter(m_destroyed_components));
    }

    void destroyed(std::initializer_list<entity_comp_id_pair> list) {
        std::copy(list.begin(), list.end(), std::back_inserter(m_destroyed_components));
    }

    /**
     * @brief Serializes desired entities and components.
     * @tparam Archive The archive type.
     * @param archive An output archive reference.
     */
    template<typename Archive>
    void serialize(Archive &archive) {
        static_assert(Archive::is_output::value, "Output archive expected.");

        // Updated entities.
        archive(m_updated_entities);

        // Updated components.
        auto num_updated = m_updated_components.size();
        archive(num_updated);

        for (auto pair : m_updated_components) {
            auto entity = pair.first;
            archive(entity);
            auto comp_id = pair.second;
            archive(comp_id);
            serialize_component(archive, entity, comp_id);
        }

        // Destroyed components.
        auto num_destroyed = m_destroyed_components.size();
        archive(num_destroyed);

        for (auto pair : m_destroyed_components) {
            archive(pair.first, pair.second);
        }
    }

protected:
    std::vector<entt::entity> m_updated_entities;
    std::vector<entity_comp_id_pair> m_updated_components;
    std::vector<entity_comp_id_pair> m_destroyed_components;
    entt::registry *m_registry;
};

//-----------------------------------------------------------------------------

/**
 * @brief The `registry_snapshot_reader` stores a reference to a registry and when 
 * serialized it reads the entities and components from the data buffer and assigns
 * or replaces the components found in the buffer into the associated target registry.
 */
template<typename... Component>
class registry_snapshot_reader {
protected:
    template<typename Func, component_identifier_t... Indexes>
    void visit(entt::entity entity, component_identifier_t comp_id, Func func, std::integer_sequence<component_identifier_t, Indexes...>) {
        ((comp_id == Indexes ? func(std::tuple_element_t<Indexes, tuple_type>{}) : (void)0), ...);
    }

    template<typename Func>
    void visit(entt::entity entity, component_identifier_t comp_id, Func func) {
        visit(entity, comp_id, func, std::make_integer_sequence<component_identifier_t, sizeof...(Component)>{});
    }

public:
    using tuple_type = std::tuple<Component...>;

    registry_snapshot_reader(entt::registry &reg) 
        : m_registry(&reg)
    {}

    registry_snapshot_reader(entt::registry &reg, [[maybe_unused]] tuple_type) 
        : m_registry(&reg)
    {}

    template<typename Archive>
    void serialize(Archive &archive) {
        static_assert(Archive::is_input::value, "Input archive expected.");

        // Updated entities;
        size_t num_entities;
        archive(num_entities);

        for (size_t i = 0; i < num_entities; ++i) {
            entt::entity entity;
            archive(entity);
        }

        // Updated components.
        size_t num_components;
        archive(num_components);

        for (size_t i = 0; i < num_components; ++i) {
            entt::entity entity;
            archive(entity);
            component_identifier_t comp_id;
            archive(comp_id);
            visit(entity, comp_id, [&] (auto &&comp) {
                archive(comp);
                if (m_registry->valid(entity)) {
                    m_registry->emplace_or_replace<std::decay_t<decltype(comp)>>(entity, std::move(comp));
                }
            });
        }

        // Destroyed components.
        size_t num_destroyed_components;
        archive(num_destroyed_components);

        for (size_t i = 0; i < num_destroyed_components; ++i) {
            entt::entity entity;
            archive(entity);
            component_identifier_t comp_id;
            archive(comp_id);
            visit(entity, comp_id, [&] (auto &&comp) {
                m_registry->remove<std::decay_t<decltype(comp)>>(entity);
            });
        }

        // Read "unmapped" entities which are encoded separately.
        /*size_t num_unmapped_entities;
        archive(num_unmapped_entities);

        for (size_t i = 0; i < num_unmapped_entities; ++i) {
            entt::entity remote_entity;
            archive(remote_entity);
            entt::entity local_entity;

            if (m_entity_map.count(remote_entity)) {
                local_entity = m_entity_map.at(remote_entity);
            } else {
                local_entity = m_registry->create();
                m_entity_map[remote_entity] = local_entity;
            }

            size_t num_components;
            archive(num_components);

            for (size_t j = 0; j < num_components; ++j) {
                component_identifier_t comp_id;
                archive(comp_id);
                visit(local_entity, comp_id, [&] (auto &&comp) {
                    archive(comp);
                    if (m_registry->valid(local_entity)) {
                        m_registry->emplace_or_replace<std::decay_t<decltype(comp)>>(local_entity, std::move(comp));
                    }
                });
            }
        }*/
    }

protected:
    entt::registry *m_registry;
    //std::unordered_map<entt::entity, entt::entity> *m_entity_map;
};

//-----------------------------------------------------------------------------

/**
 * @brief Exports data from the registry mapping entities into the corresponding
 *      entities in another registry. The data can later be loaded into the
 *      other registry using `registry_snapshot_reader`.
 */
template<typename... Component>
class registry_snapshot_exporter {
    
    template<typename Other, typename Type, typename Member>
    void update_child_entity(Other &instance, Member Type:: *member) const {
        if constexpr(!std::is_same_v<Other, Type>) {
            return;
        } else if constexpr(std::is_same_v<Member, entt::entity>) {
            instance.*member = m_map->locrem(instance.*member);
        } else {
            // Attempt to use member as a container of entities.
            for(auto &ent : instance.*member) {
                ent = m_map->locrem(ent);
            }
        }
    }

    template<typename Comp, typename Archive, typename... Type, typename... Member>
    void serialize_component(Archive &archive, entt::entity entity, Member Type:: *...member) const {
        if (m_registry->has<Comp>(entity) && m_map->has_loc(entity)) {
            auto remote_entity = m_map->locrem(entity);
            archive(remote_entity);
            auto comp_id = index_of_v<component_identifier_t, Comp, Component...>;
            archive(comp_id);
            if constexpr(!std::is_empty_v<Comp>) {
                // Note that a copy component is obtained instead of a reference,
                // thus the original component is not affected.
                auto comp = m_registry->get<Comp>(entity);
                (update_child_entity(comp, member), ...);
                archive(comp);
            }
        }
    }

    template<typename Archive, typename... Type, typename... Member, component_identifier_t... Indexes>
    void serialize_component(Archive &archive, entt::entity entity, component_identifier_t comp_id, std::integer_sequence<component_identifier_t, Indexes...>, Member Type:: *...member) const {
        ((comp_id == Indexes ? serialize_component<std::tuple_element_t<Indexes, tuple_type>>(archive, entity, member...) : (void)0), ...);
    }

    template<typename Archive, typename... Type, typename... Member>
    void serialize_component(Archive &archive, entt::entity entity, component_identifier_t comp_id, Member Type:: *...member) const {
        serialize_component(archive, entity, comp_id, std::make_integer_sequence<component_identifier_t, sizeof...(Component)>{}, member...);
    }
    
public:
    using tuple_type = std::tuple<Component...>;

    registry_snapshot_exporter(entt::registry &reg, entity_map &map) 
        : m_registry(&reg)
        , m_map(&map)
    {}

    template<typename... Comp>
    void updated(entt::entity entity) {
        m_updated_entities.push_back(entity);
        if constexpr(sizeof...(Comp) > 0) {
            ((m_registry->has<Comp>(entity) ? m_updated_components.push_back(entity_comp_id_pair{entity, component_identifier<Component...>::template value<Comp>}) : (void)0), ...);
        }
    }

    template<typename... Comp>
    void updated(entt::entity entity, [[maybe_unused]] std::tuple<Comp...>) {
        updated<Comp...>(entity);
    }

    template<typename It>
    void updated(It first, It last) {
        for (auto it = first; it != last; ++it) {
            auto entity = it->first;
            m_updated_entities.push_back(entity);
        }
        std::copy(first, last, std::back_inserter(m_updated_components));
    }

    template<typename... Comp>
    void destroyed(entt::entity entity) {
        (m_destroyed_components.push_back(entity_comp_id_pair{entity, component_identifier<Component...>::template value<Comp>}), ...);
    }

    template<typename It>
    void destroyed(It first, It last) {
        std::copy(first, last, std::back_inserter(m_destroyed_components));
    }

    void destroyed(std::initializer_list<entity_comp_id_pair> list) {
        std::copy(list.begin(), list.end(), std::back_inserter(m_destroyed_components));
    }

    template<typename Archive, typename... Type, typename... Member>
    void serialize(Archive &archive, Member Type:: *...member) {
        static_assert(Archive::is_output::value, "Output archive expected.");

        // Updated entities.
        size_t num_updated_entities = std::accumulate(m_updated_entities.begin(), m_updated_entities.end(), 
            size_t{0}, [&] (auto count, auto e) { return count + m_map->has_loc(e); });
        archive(num_updated_entities);

        for (auto local_entity : m_updated_entities) {
            if (m_map->has_loc(local_entity)) {
                auto remote_entity = m_map->locrem(local_entity);
                archive(remote_entity);
            }
        }
        
        // Updated components.
        size_t num_updated_components = std::accumulate(m_updated_components.begin(), m_updated_components.end(), 
            size_t{0}, [&] (auto count, auto pair) { return count + m_map->has_loc(pair.first); });
        archive(num_updated_components);

        for (auto pair : m_updated_components) {
            auto local_entity = pair.first;
            auto comp_id = pair.second;
            // It only serializes the component if there is a mapping for `local_entity`.
            serialize_component(archive, local_entity, comp_id, member...);
        }

        // Destroyed components.
        size_t num_destroyed_components = std::accumulate(m_destroyed_components.begin(), m_destroyed_components.end(), 
            size_t{0}, [&] (auto count, auto pair) { return count + m_map->has_loc(pair.first); });
        archive(num_destroyed_components);

        for (auto pair : m_destroyed_components) {
            auto local_entity = pair.first;
            if (!m_map->has_loc(local_entity)) continue;
            auto remote_entity = m_map->locrem(local_entity);
            auto comp_id = pair.second;
            archive(remote_entity, comp_id);
        }

        // Write entities not present in the entity map separately.
        /* 
        auto total_entities = std::distance(first, last);
        auto num_unmapped_entities = total_entities - num_entities;
        archive(num_unmapped_entities);

        for (auto entity : m_entities) {
            if (snapshot.m_map->has_loc(entity)) continue;

            archive(entity);

            size_t count = 0;
            for (auto comp_id : m_component_ids) {
                if (has(entity, comp_id)) {
                    ++count;
                }
            }
            archive(count);

            for (auto comp_id : m_component_ids) {
                try_visit(entity, comp_id, [&archive, &comp_id] (auto *comp) {
                    if (comp) {
                        archive(comp_id);
                        archive(*comp);
                    }
                });
            }
        } */
    }

private:
    entt::registry *m_registry;
    entity_map *m_map;
    std::vector<entt::entity> m_updated_entities;
    std::vector<entity_comp_id_pair> m_updated_components;
    std::vector<entity_comp_id_pair> m_destroyed_components;
};

//-----------------------------------------------------------------------------

/**
 * @brief Imports entities and components from one registry into another, 
 *      creating a mapping between entities. An existing map must be provided.
 *      If the external entity is not yet present in the map, a new entity will
 *      be created in the registry plus a mapping will be added connecting local
 *      to extenal entity. The same map should be reused in subsequent imports.
 */
template<typename... Component>
class registry_snapshot_importer {

    template<typename Func, component_identifier_t... Indexes>
    void visit(entt::entity entity, component_identifier_t comp_id, Func func, std::integer_sequence<component_identifier_t, Indexes...>) {
        ((comp_id == Indexes ? func(std::tuple_element_t<Indexes, tuple_type>{}) : (void)0), ...);
    }

    template<typename Func>
    void visit(entt::entity entity, component_identifier_t comp_id, Func func) {
        visit(entity, comp_id, func, std::make_integer_sequence<component_identifier_t, sizeof...(Component)>{});
    }

    template<typename Other, typename Type, typename Member>
    void update_child_entity(Other &instance, Member Type:: *member) const {
        if constexpr(!std::is_same_v<Other, Type>) {
            return;
        } else if constexpr(std::is_same_v<Member, entt::entity>) {
            instance.*member = m_map->remloc(instance.*member);
        } else {
            // Attempt to use member as a container of entities.
            for(auto &ent : instance.*member) {
                ent = m_map->remloc(ent);
            }
        }
    }

public:
    using tuple_type = std::tuple<Component...>;

    registry_snapshot_importer(entt::registry &reg, entity_map &map) 
        : m_registry(&reg)
        , m_map(&map)
    {}

    template<typename Archive, typename... Type, typename... Member>
    void serialize(Archive &archive, Member Type:: *...member) {
        static_assert(Archive::is_input::value, "Input archive expected.");

        // Updated entities.
        size_t num_updated_entities;
        archive(num_updated_entities);

        for (size_t i = 0; i < num_updated_entities; ++i) {
            entt::entity remote_entity;
            archive(remote_entity);
            
            if (!m_map->has_rem(remote_entity)) {
                auto entity = m_registry->create();
                m_map->insert(remote_entity, entity);
            }
        }

        // Updated components.
        size_t num_updated_components;
        archive(num_updated_components);

        for (size_t i = 0; i < num_updated_components; ++i) {
            entt::entity remote_entity;
            archive(remote_entity);
            
            entt::entity entity;
            if (m_map->has_rem(remote_entity)) {
                entity = m_map->remloc(remote_entity);
            } else {
                entity = m_registry->create();
                m_map->insert(remote_entity, entity);
            }

            component_identifier_t comp_id;
            archive(comp_id);

            visit(entity, comp_id, [&] (auto &&comp) {
                archive(comp);
                (update_child_entity(comp, member), ...);

                if (m_registry->valid(entity)) {
                    m_registry->emplace_or_replace<std::decay_t<decltype(comp)>>(entity, std::move(comp));
                }
            });
        }

        // Deleted components.
        size_t num_deleted_components;
        archive(num_deleted_components);

        for (size_t i = 0; i < num_deleted_components; ++i) {
            entt::entity remote_entity;
            archive(remote_entity);

            component_identifier_t comp_id;
            archive(comp_id);

            if (m_map->has_rem(remote_entity)) {
                auto entity = m_map->remloc(remote_entity);

                visit(entity, comp_id, [&] (auto &&comp) {
                    if (m_registry->valid(entity)) {
                        m_registry->remove<std::decay_t<decltype(comp)>>(entity);
                    }
                });
            }
        }
    }

private:
    entt::registry *m_registry;
    entity_map *m_map;
};

}

#endif // EDYN_SERIALIZATION_REGISTRY_S11N_HPP